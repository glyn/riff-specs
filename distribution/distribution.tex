\documentclass[a4paper,twoside,12pt]{article}
\usepackage{../z/zed-cm}
\usepackage{graphicx}
\usepackage[nottoc,numbib]{tocbibind}
%\usepackage{hyperref}
\markboth{Draft}{Version 0.1}
\pagestyle{myheadings}
\begin{document}
\parskip 10 pt
\parindent 0 pt

\def\Slash{\slash\hspace{0pt}}

\title{Image Registries}

\author{Glyn Normington}

\maketitle
% The following three commands ensure the title page is without a page number but page numbering starts here.
% Page numbers appear on subsequent pages, and are roman until the main body, which starts again at arabic 1.
\thispagestyle{empty}
\pagenumbering{roman}
\setcounter{page}{1}

%=============================================================================

This document provides a formal model of image registries.

% Alt-Cmd-M -- \emph{}
% Alt-Cmd-Z -- \zed{}
% Alt-Cmd-X -- \axdef{}
% Alt-Cmd-S -- \schema{}
% Alt-Shift-Cmd-T -- \texttt{}

% Type checking hacks
\newcommand{\true}{true}
\newcommand{\false}{false}
\renewcommand{\emptyset}{\varnothing}
%=============================================================================

\clearpage
\tableofcontents

\cleardoublepage
\pagenumbering{arabic}
\setcounter{page}{1}

%=============================================================================
\section{Introduction}

This document provides a formal model of image registries.

%=============================================================================
\section{Overview of this document}

Docker Inc.\ introduced container images and registries to hold them and these were later standardised as part of the Open Container Initiative. The reader is assumed to have a basic understanding of how images are used.

This document models image references, repositories, and registries. It covers digests and tags.

The Z specification language is used to capture the model, but sufficient English text is also provided that readers who do not know Z should be able to understand the model. The appendix contains a summary of the Z notation.
For more information about Z, please consult the Z Manual (\texttt{https://www.cs.umd.edu/~mvz/handouts/z-manual.pdf}).
The model was type checked using \texttt{fuzz} (\texttt{https://bitbucket.org/Spivey/fuzz}).

I am grateful to Chris Frost for his helpful comments on this document.

%=============================================================================
\section{Fundamentals}

Images are opaque blobs as far as we are concerned here - the decomposition into layers is ignored.
Similarly, cryptographic hashes (or \textit{hexes} to use the terminology of the OCI Distribution specification), tags, and (registry) hostnames and paths are modelled, but their details are not.
\begin{zed}
[ Image, Hex, Tag, Hostname, Path ] 
\end{zed}

There is a special reserved tag.
\begin{axdef}
    Latest : Tag
\end{axdef}

%=============================================================================
\newpage
\section{Content Digests}

A content digest is a combination of a cryptographic hash function (such as \texttt{SHA-256}) or ``algorithm'', and the hash output by such a function. 
\begin{schema}{ContentDigest}
    alg: Image \fun Hex \\
    hash: Hex \\ 
\end{schema}

The idea is that a content digest $d$ identifies an image $i$ if and only if applying the hash function (from the content digest) to the image produces the hash output in the content digest:\\
%%unchecked
\begin{zed}
\t1 d.alg~i = d.hash
\end{zed}

An optional content digest is modelled as a datatype.
\begin{zed}
    OptionalContentDigest ::= None | Dig \ldata ContentDigest \rdata
\end{zed}

%=============================================================================
\newpage
\section{Repositories}

A repository is a collection of images indexed by content digest and by tag.
\begin{schema}{Repo}
    cd: ContentDigest \pfun Image \\
    tag: Tag \pfun Image \\
\where
    \forall d : \dom cd @ d.alg~(cd~d) = d.hash \\
    \ran tag \subseteq \ran cd \\
\end{schema}
The content digests identify the corresponding images. Each image identified by a tag is also identified by a content digest.

Initially, a repository is empty.
\begin{schema}{RepoInit}
  Repo' \\
\where
  cd' = \emptyset \\
  tag' = \emptyset \\
\end{schema}
 
\begin{samepage}
An image is added to a repository by \textit{pushing} it.
\begin{schema}{RepoPush}
  \Delta Repo \\
  i? : Image \\
  t? : Tag \\
  d! : ContentDigest
\where
  tag' = tag \oplus \{ t? \mapsto i? \} \\
  cd' = cd \oplus \{ d! \mapsto i? \} \\
\end{schema}
The tag may be omitted in practice in which case it defaults to $Latest$. Note that the invariant of $Repo'$ ensures that the output digest identifies the input image. However, there is some non-determinism here in the choice of algorithm.
\end{samepage}

An image is retrieved from a repository by \textit{pulling} it.

We can either pull using a content digest
\begin{schema}{RepoPullByDigest}
  \Xi Repo \\
  d? : OptionalContentDigest \\
  i! : Image \\
\where
  \exists d : ContentDigest | d? = Dig~d  \land d \in \dom cd @ i! = cd~d \\
\end{schema}

or, if a content digest is not supplied, by using a tag.
\begin{schema}{RepoPullByTag}
  \Xi Repo \\
  t? : Tag \\
  d? : OptionalContentDigest \\
  i! : Image \\
\where
  d? = None \\
  t? \in \dom tag \implies i! = tag~t? \\
\end{schema}

\begin{samepage}
A successful pull operation uses either a content digest or a tag.
\begin{zed}
  RepoPullOk \defs RepoPullByDigest \lor RepoPullByTag
\end{zed}
Failure cases, such as ``not found'', are omitted from the model.
\end{samepage}

%=============================================================================
\newpage
\section{Registries}

A registry is a collection of repositories index by path.
\begin{schema}{Registry}
    repo: Path \fun Repo \\
\end{schema}
Paths which do not exist are modelled as pointing to empty repositories.

Initially a registry has only empty repositories.
\begin{schema}{RegistryInit}
  Registry' \\
\where
  \forall p : Path @ \\
  \t1 \exists RepoInit @ \\
  \t2 repo'~p = \theta Repo' \\
\end{schema}

\begin{samepage}
We define a promotion schema\footnote{Promotion schemas are used to turn operations on a particular type into operations on collection of the type which operate on a single member of the collection and leave the rest unchanged} which operates on a single repository in a registry.
\begin{schema}{RegistryPromote}
  \Delta Registry \\
  \Delta Repo \\
  p? : Path \\
\where
  p? \in \dom repo \\
  \theta Repo = repo~p? \\
  repo' = repo \oplus \{ p? \mapsto \theta Repo' \} \\
\end{schema}
The path must be valid and the registry is preserved except for the repository identified by the path which may be updated.
\end{samepage}

We then promote the repository push and pull operations to operate on a registry.
\begin{zed}
  RegistryPush \defs \exists \Delta Repo @ RepoPush \land RegistryPromote \\
  RegistryPullOk \defs \exists \Delta Repo @ RepoPullOk \land RegistryPromote \\
\end{zed}
  
Registries are arranged in a network indexed by hostname.
\begin{schema}{Net}
    reg: Hostname \pfun Registry \\
\end{schema}

Initiallly, there are no registries in the network.
\begin{schema}{NetInit}
  Net'
\where
  reg' = \emptyset
\end{schema}

We can add an empty registry to the network.
\begin{schema}{NetAddRegistryOk}
  \Delta Net \\
  h? : Hostname \\
\where
  h? \notin \dom reg \\
  \exists RegistryInit @ reg' = reg \cup \{ h? \mapsto \theta Registry' \} \\
\end{schema}

We can also remove a registry from the network.
\begin{schema}{NetRemoveRegistryOk}
  \Delta Net \\
  h? : Hostname \\
\where
  h? \in \dom reg \\
  reg' = \{ h? \} \ndres reg \\
\end{schema}

\begin{samepage}
We define a promotion schema which operates on a single registry in a network.
\begin{schema}{NetPromote}
  \Delta Net \\
  \Delta Registry \\
  h? : Hostname \\
\where
  h? \in \dom reg \\
  \theta Registry = reg~h? \\
  reg' = reg \oplus \{ h? \mapsto \theta Registry' \} \\
\end{schema}
The hostname must be valid and the network is preserved except for the registry identified by the hostname which may be updated.
\end{samepage}

\begin{samepage}
Finally, we promote the push and pull operations to work on a network.
\begin{zed}
  NetPushOk \defs \exists \Delta Registry @ RegistryPush \land NetPromote \\
  NetPullOk \defs \exists \Delta Registry @ RegistryPullOk \land NetPromote
\end{zed}
Pushing and pulling can fail if there is no registry with the input hostname.
\end{samepage}

%=============================================================================
\newpage
\section{Image References}

An image reference identifies an image in a registry. Let's remind ourselves what image references look like.

An image reference consists of a hostname (with optional port) and a path. The image reference may also contain a tag and/or a digest. The hostname determines the network location of a registry. The path consists of one or more components separated by forward slashes. The first component is sometimes, by convention for certain registries, a user name providing access control to the image.

Let's look at some examples:
\begin{itemize}
\item The image name \texttt{docker.io/istio/proxyv2} refers to an image with user name \texttt{istio} residing in the docker hub registry at \texttt{docker.io}.

\item The image name \texttt{projectriff/builder:v1} is short-hand for\linebreak
\texttt{docker.io/projectriff/builder:v1} which refers to an image with user name \texttt{projectriff} also residing at \texttt{docker.io}. The image has tag \texttt{v1}.

\item The image name \texttt{gcr.io/cf-elafros/knative-releases/github.com}\linebreak\texttt{/knative/serving/cmd/autoscaler@sha256:deadbeefdeadbeef}\linebreak\texttt{deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef} refers to an image with user name \texttt{cf-elafros} residing at \texttt{gcr.io}. The image has a (made up) \texttt{SHA-256} digest.
\end{itemize}

For the purposes of our model, an image reference consists of a hostname, a path, a tag, and an optional content digest.
\begin{schema}{Ref}
    host: Hostname \\
    path: Path \\
    tag: Tag \\
    dig : OptionalContentDigest \\
\end{schema}
A tag is always logically present, but if it is omitted from the textual representation of an image reference, it defaults to $Latest$.
A content digest may be part of an image reference or may be omitted.

So far the push and pull operations have accumulated several input parameters.
\begin{schema}{PushParms}
    h? : Hostname \\
    p? : Path \\
    t? : Tag \\
\end{schema}
\begin{schema}{PullParms}
    h? : Hostname \\
    p? : Path \\
    t? : Tag \\
    d? : OptionalContentDigest \\
\end{schema}

\begin{samepage}
An image reference is mapped to push input parameters as follows.
\begin{schema}{RefPushParms}
    r? : Ref \\
    PushParms \\
\where
    h? = r?.host \\
    p? = r?.path \\
    t? = r?.tag \\
    r?.dig = None \\
\end{schema}
Pushing is not allowed if the image reference has a content digest.
\end{samepage}

An image reference is mapped to pull input parameters as follows.
\begin{schema}{RefPullParms}
    r? : Ref \\
    PullParms \\
\where
    h? = r?.host \\
    p? = r?.path \\
    t? = r?.tag \\
    d? = r?.dig \\
\end{schema}

Push and pull can then be reframed to take an image reference instead of the corresponding input parameters.
\begin{zed}
  RefPushOk \defs \exists PushParms @ NetPushOk \land RefPushParms \\
  RefPullOk \defs \exists PullParms @ NetPullOk \land RefPullParms \\
\end{zed}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   A P P E N D I C E S
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\clearpage

\appendix

%=============================================================================
%   Z   N O T A T I O N
%=============================================================================
\input{../z/z-notation.tex}

%=============================================================================
%   B I B L I O G R A P H Y
%=============================================================================
%\newpage
%\begin{flushleft}
%\begin{thebibliography}{99}
%\label{sec:references}
% `99' is a picture of the generated numeric references -- they are two digits in this bibliography
% If we had a hundred or more we would have used 999, or whatever.

%%  Example bibliography entry:
%\bibitem{knuth76}                                                        % citation callout, e.g.: \cite{knuth76}
%  Donald E. Knuth,                                                        % author
%  \emph{The computer as Master Mind}.                    % title
%  J. Recreational Mathematics, Vol.~9(1), 1976-1977. % publisher, or journal, volume and date

%\end{thebibliography}
%\end{flushleft}
\end{document}
